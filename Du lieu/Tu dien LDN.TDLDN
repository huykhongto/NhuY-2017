SPDR ATmega8~~1Thanh ghi thiết lập SPI cho AVR~~2~~3~~4~~5
Thiết lập timer 1 PIC CCS~~1setup_timer_1(T1_INTERNAL|T1_DIV_BY_4);      //21,8 ms overflowp``Timer 1 chỉ ở chế độ 16 bit``Syntax:`` setup_timer_1 (mode)``Parameters:`` mode values may be:``T1_DISABLED, T1_INTERNAL, T1_EXTERNAL, T1_EXTERNAL_SYNC``T1_CLK_OUT``T1_DIV_BY_1, T1_DIV_BY_2, T1_DIV_BY_4, T1_DIV_BY_8``constants from different groups may be or'ed together with |.``Returns:`` undefined``Function:`` Initializes timer 1. The timer value may be read and written to using SET_TIMER1() and GET_TIMER1()Timer 1 is a 16 bit timer.  ``With an internal clock at 20mhz and with the T1_DIV_BY_8 mode, the timer will increment every 1.6us. It will overflow every 104.8576ms.``Availability:`` This function is only available on devices with timer 1 hardware.``Requires:`` Constants are defined in the devices .h file.``Examples:`` setup_timer_1 ( T1_DISABLED );``setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_4 );``setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_8 );~~2~~3~~4~~5~~6
Thiết lập timer 2 PIC CCS~~1setup_timer_2(T2_DIV_BY_16,100,1); // 1,3 us overflow, 1,3 us interrup``Timer 2 chỉ ở chế độ 8 bit````Syntax:`` setup_timer_2 (mode, period, postscale)```` `` ``Parameters:`` mode may be one of:````T2_DISABLED````T2_DIV_BY_1, T2_DIV_BY_4, T2_DIV_BY_16````Period is a int 0-255 that determines when the clock value is reset````Postscale is a number 1-16 that determines how many timer overflows````before an interrupt: (1 means once, 2 means twice, an so on)```` `` ``Returns:`` undefined```` `` ``Function:`` Initializes timer 2. The mode specifies the clock divisor (from the oscillator clock).````The timer value may be read and written to using GET_TIMER2() and SET_TIMER2().  ````2 is a 8-bit counter/timer.```` `` ``Availability:`` This function is only available on devices with timer 2 hardware.```` `` ``Requires:`` Constants are defined in the devices .h file.```` `` ``Examples:`` setup_timer_2 ( T2_DIV_BY_4, 0xc0, 2)   //at 20mhz, the timer will````                                        //increment every 800ns````                                        //will overflow every 154.4us,````                                        //and will interrupt every 308.us`` ~~2~~3~~4~~5~~6
%10~~1	a=a%10; // chia lấy dư, c CCS``Ví dụ: a=15; a=a%10; // a=5~~2~~3~~4~~5~~6
(1<<ADSC)~~1Bắt đầu chuyển đổi ADC. Mất 25 chu kỳ xung Atmega32``ADCSRA |= ((1<<ADEN) | (1<<ADSC) | (1<<ADPS1));~~2~~3~~4~~5~~6
{$IFDEF UNICODE}~~1{$IFDEF UNICODE} // Nếu sử dụng mã Unicode~~2~~3~~4~~5~~6
<< Lệnh dịch trái trong C~~1unsigned int uint=0x1;``	uint=uint<<8; // dịch trái 8 bit``// uint = 0x100~~2~~3~~4~~5~~6
>> Lệnh dịch phải trong C~~1unsigned int uint=0x1000;``	uint=uint>>8; // dịch phải 8 bit``// uint = 10~~2~~3~~4~~5~~6
16 BIT TO bcd, chuyen doi so 16 bit sang bcd ASM MCS51~~1;``;  +-------------------------------------------------------------------------+``;  | Purpose: Routine to convert a 16bit binary number in ASCII``;  |                                                                         |``;  | INPUT : R2 (Lsb) and R3 (Msb)   ( binary)                               |``;  |                                                                         |``;  | OUPUT : 30h,31h,32h,33h,34h  (internal RAM address)  (ASCII)            |``;  |   msb--^                  ^------lsb                                       |``;  |                                                                         |``;  | Destroy all registers                                                   |``;  |                                                                         |``;  | PROGRAMMER: Bruno Marcio Diogo Venancio ( bruno.marcio@bol.com.br )     |``;  | BRAZIL 07/19/2002                                                       |``;  |          THIS CODE CAN BE FREELY DISTRIBUTED WITHOUT CHANGES            |``;  +-------------------------------------------------------------------------+``;``; Use example:    ``;                      ``;START:``;        MOV R2,#low(1234)                                ``;        MOV R3,#high(1234)``;        LCALL  BINTOASC``;       ``;   in 30h until 34h of internal RAM will be :'0','1',' 2',','3','4' ( ASCII)``;``;``;             The Routine Algorithm``;``;``;                  +-------+``;                  | START |``;                  +---+---+``;                      |         ``;                  +-------+``;                  |   N   |        ( N= Number to be coverted)``;                  +-------+``;                      |``;                +-------------+``;                | POUT   <- 0 |    ( POUT = Output address )        ``;                +-------------+``;                      |``;                 +--------+``;                 | P <- 0 |      ( P= Table Index )``;                 +--------+``;                      |``;                      |``;     +----------->    | ``;     |           +-------------+ ( R = Register )``;     |           | R <- TAB(P) | ( Fetch a table number indexed by P ) ``;     |           +-------------+``;     |                |``;     |           +----------+``;     |           | C <- '0' |    ( C= counter)``;     |           +----------+    ( counter <- 0 in ASCII)``;     |                |``;     |    +------>    |``;     |    |      +-----------+``;     |    |      | N <-  N-R |   ( subtract the table number with R )``;     |    |      +-----------+                                          ``;     |    |           |``;     |    |      N   /  \   Y``;     |    |     +--< N<0? >-----------+``;     |    |     |   \    /            |``;     |    |     |     \/              |``;     |    |     |             +--------------------+``;     |    |  +-------+        | TABOUT (POUT) <- C |``;     |    |  |C<- C+1|        +--------------------+``;     |    |  +-------+                |``;     |    |     |                +----------+``;     |    +-----+                | N <- N+R |``;     |                           +----------+``;     |                                |``;     |                       +------------------+``;     |                       | POUT  <- POUT +1 |``;     |                       +------------------+``;     |                                |``;     |                               /^\``;     |                             /     \``;     |   +----------+         N  /         \ S``;     +---| P <- P+1 |-----------< TAB(P)=1? > ---------+``;         +----------+            \         /           |``;                                   \     /             |``;                                     \ /               |``;                                                    +-----+``;                                                    | END |``;                                                    +-----+``;``;           `` ``BINTOASC:````        MOV R0,#30h                 ; R0 = POUT ``        MOV DPTR,#TAB               ; R=TAB(P)````COM1:````        CLR A                       ; P <- 0     ``        MOVC A,@A+DPTR              ; R <-  TAB(P)``        MOV R7,A``        INC DPTR``        CLR A``        MOVC A,@A+DPTR``        MOV R6,A````        MOV R4,#'0'                  ; C  <- '0'``````SOMA:                                ; N <-  N-R ``      CLR C        ;              ``      MOV A,R2     ;              ``      SUBB A,R6    ;              ``      MOV R2,A     ;              ``                                 ``      MOV A,R3     ;               ``      SUBB A,R7    ;              ``      MOV R3,A     ;              ``      JC SAIDA     ;    If < 0 goto  SAIDA``      INC R4       ;    If >0 then C <- C +1``      SJMP SOMA    ;    goto SOMA            ``SAIDA:``      MOV A,R4                 ``      MOV @R0,A              ;TABOUT (POUT) <- C````      MOV A,R2             ``      ADD A,R6               ;  N=N+R``      MOV R2,A             ``                           ``      MOV A,R3             ``      ADDC A,R7            ``      MOV R3,A             ````      INC R0                 ; PSAIDA=PSAIDA +1````      CLR A``      MOVC A,@A+DPTR``      CJNE A,#1,INCREMENTA   ; TAB(P) = 1 ?``      RET                    ; If yes, END````INCREMENTA:                  ; If No, P <- P+1``      INC DPTR``      LJMP COM1              ; goto COM1``````TAB:``     DW 10000``     DW 1000``     DW 100``     DW 10``     DW 1``````;------------------------------- Cut here  8<---------------------------~~2~~3~~4~~5~~6
24C02.C MCS51. 89C51~~1#define uint  unsigned int``#define ulong unsigned long``#include <reg52.h>     //包括一个52标准内核的头文件````char code dx516[3] _at_ 0x003b;//这是为了仿真设置的````#define	WriteDeviceAddress 0xa0	  //定义器件在IIC总线中的地址``#define	ReadDviceAddress 0xa1``sbit	SCL=P2^7;``sbit	SDA=P2^6;````sbit 	P10=P1^0;````//定时函数``void DelayMs(unsigned int number) ``{``	unsigned char temp;``	for(;number!=0;number--) ``	{``		for(temp=112;temp!=0;temp--) ;``	}``}````//开始总线``void Start() ``{``	SDA=1;``	SCL=1;``	SDA=0;``	SCL=0;``}````//结束总线``void Stop() ``{``	SCL=0;``	SDA=0;``	SCL=1;``	SDA=1;``}``````//发ACK0``void NoAck() ``{``	SDA=1;``	SCL=1;``	SCL=0;``}````//测试ACK``bit TestAck() ``{``	bit ErrorBit;``	SDA=1;``	SCL=1;``	ErrorBit=SDA;``	SCL=0;``	return(ErrorBit);``}````//写入8个bit到24c02``Write8Bit(unsigned char input) ``{``	unsigned char temp;``	for(temp=8;temp!=0;temp--) ``	{``		SDA=(bit)(input&0x80);``		SCL=1;``		SCL=0;``		input=input<<1;``	}``}````//写入一个字节到24c02中``void Write24c02(uchar ch,uchar address) ``{``	Start();``	Write8Bit(WriteDeviceAddress);``	TestAck();``	Write8Bit(address);``	TestAck();````	Write8Bit(ch);``	TestAck();``	``	Stop();``	DelayMs(10);``}````//从24c02中读出8个bit``uchar Read8Bit() ``{``	unsigned char temp,rbyte=0;``	for(temp=8;temp!=0;temp--) ``	{``		SCL=1;``		rbyte=rbyte<<1;``		rbyte=rbyte|((unsigned char)(SDA));``		SCL=0;``	}``	return(rbyte);``}````//从24c02中读出1个字节``uchar Read24c02(uchar address) ``{``	uchar ch;````	Start();``	Write8Bit(WriteDeviceAddress);``	TestAck();``	Write8Bit(address);``	TestAck();``	Start();``	Write8Bit(ReadDviceAddress);``	TestAck();``	ch=Read8Bit();``	NoAck();``	Stop();``	return(ch);``}````//本课试验写入一个字节到24c02并读出来验证````void main(void)	// 主程序``{``	uchar c1,c2;``	c1=Read24c02(0x02);````	Write24c02(0x99,0x03);``	c2=Read24c02(0x03);````	P10=0;``	while(1);  //程序挂起````}~~2~~3~~4~~5~~6
24C04 MCS51 C 2 LCD C~~1#include <intrins.h>````#define uchar unsigned char``#define uint unsigned int````#define write_device_address 0xa0  //24c04地址1010 0000：高4位固定为1010，最后一位0写1读，余下三位器件地址位``#define read_device_address 0xa1 ``   ``sbit SCL_24c04=P1^3;``sbit SDA_24c04=P1^4;````sbit led2=P3^3;``sbit led3=P3^2;``uchar readbyte;``````void I2C_Init(void);``void I2C_Start(void);``void I2C_Stop(void);``bit I2C_Clock_SDA(void);``bit I2C_SendByte(uchar Byte);``uchar I2C_ReceiveByte(void); ````bit WriteByte_to_24c04(uchar write_data_address,uchar write_bytedata);``bit ReadByte_from_24c04(uchar read_data_address);````void delay_us(void);````/*------------LCD--------------------------------------------------------------------------------------------------------------*/``sbit RS=P3^5;  /*数据/命令选择端*/``sbit RW=P3^6;  /*读写控制信号*/``sbit  E=P3^7;  /*使能信号*/``````void initial(void);``void delayms(int j);``void write_data_to_LCD(uchar write_data);``void write_command_to_LCD(uchar write_cmd,uchar testbusy);``void wait_for_permit(void);``````/***********初始化函数*************/``void initial(void)``{``   delayms(15);//delay 15ms``   write_command_to_LCD(0x38,0); //显示模式设置，不检测忙信号``   delayms(5);``   write_command_to_LCD(0x38,0); //显示模式设置，不检测忙信号``   delayms(5);``   write_command_to_LCD(0x38,0);//显示模式设置，不检测忙信号``                                //以后每次写指令，读写数据操作之前均需检测忙信号``   write_command_to_LCD(0x38,1); //显示模式设置，检测忙信号``   write_command_to_LCD(0x08,1);//显示关闭，检测忙信号``   write_command_to_LCD(0x01,1);//显示清屏，检测忙信号``   write_command_to_LCD(0x06,1);//显示光标移动设置，检测忙信号``   write_command_to_LCD(0x0f,1);//显示打开及光标设置，检测忙信号	    ``}``````void delayms(int delay)``{``   int i;``   for(i=0;i<delay;i++)``   {``       _nop_();``       _nop_();``   }``}``````/***********写命令函数***********/``void write_command_to_LCD(uchar write_cmd,uchar testbusy)``{``   if(testbusy)``      wait_for_permit();/*检测忙信号*/``   RS=0;``   RW=0;``   E=1;``   P2=write_cmd;``   delayms(40);``   E=0;``   delayms(40);``}``````/************写数据函数***************/``void write_data_to_LCD(uchar write_data)``{``   wait_for_permit();/*检测忙信号*/``   RS=1;``   RW=0;``   E=1;``   P2=write_data;``   delayms(40);``   E=0;``   delayms(40);``}````/**********读LCD状态函数***********/``void wait_for_permit(void)``{``  delayms(50);``  RS=0;``  RW=1;``  E=1;``  while(P2&0x80);/*忙等待*/``  E=0;``  ``}``````/*---------------------------------------------------------------------------------------------------------------------------------*/````/**************24c04延时函数***************/``void delay_us(void)``{``    _nop_();``    _nop_();``    _nop_();``    _nop_(); ``    _nop_();``    _nop_();``	  ``}````/*************I2C总线数据发送起始函数***************/``void I2C_Start(void)``{``    SDA_24c04=1;``    delay_us();``   	SCL_24c04=1;``    delay_us();````    SDA_24c04=0;//SCL时钟电平高，SDA高低跳，数据发送起始信号``    delay_us();``    SCL_24c04=0;``    delay_us();``}````/*************I2C总线数据发送结束函数***************/``void I2C_Stop(void)``{``    SDA_24c04=0;``    delay_us();``    SCL_24c04=1;``    delay_us();````    SDA_24c04=1;//SCL时钟电平高，SDA低高跳，数据发送起始信号``    delay_us();``}````/***********I2C总线初始化************/``void I2C_Init(void)``{``   SCL_24c04=0;``   I2C_Stop();``}``````/**********************************************``提供I2C总线的时钟信号，并返回在SCL_24c04=1期间``SDA_24c04的状态，本函数可以用于数据发送或接收。``***********************************************/``bit I2C_Clock_SDA(void)``{``   bit Clock_SDA;``   SCL_24c04=1;``   delay_us();````   Clock_SDA=SDA_24c04;``   SCL_24c04=0;``   delay_us();````   return(Clock_SDA);	 ``}``````/***********************************************``向I2C总线发送8位数据，并请求一个应答信号ACK，若``收到ACK应答则返回1，否则返回0。``***********************************************/``bit I2C_SendByte(uchar Byte)``{``   int i;``   for(i=0;i<8;i++)``      {``	     SDA_24c04=(bit)(Byte&0x80);//SDA_24c04的值等于Byte的最高位（即左移移出位）``		 delay_us();``		 Byte<<=1;``		 I2C_Clock_SDA();		   ``	  }``   SDA_24c04=1;``   return(~I2C_Clock_SDA());//第九个时钟周期,SDA拉低，即收到应答信号``}````/*******************************************************``从I2C总线上接收8位数据信号，并将接收到8位数据作为1B返回，``不回送应答信号ACK，``*******************************************************/``uchar I2C_ReceiveByte(void) ``{``   int i;``   uchar Byte=0;``   for(i=0;i<8;i++)``      {``	     Byte<<=1;``		 if(I2C_Clock_SDA())``		    Byte++; 		 	   ``	  }``   return(Byte);````}``````/******向24c04写一个字节的数据，存储在指定位置*******/``bit WriteByte_to_24c04(uchar write_data_address,uchar write_bytedata)``{``   bit write_ok=0;``   I2C_Start();``   if(I2C_SendByte(write_device_address))``       {  ``	         if(I2C_SendByte(write_data_address))``		        write_ok=I2C_SendByte(write_bytedata);``	   }``   else ``       write_ok=0;``   return(write_ok);``   I2C_Stop();``}````/*************从24c04读一个字节的数据***************/``bit ReadByte_from_24c04(uchar read_data_address)``{``   bit read_ok=0;``   ``   delay_us();````   I2C_Start();``   delay_us();````   if(I2C_SendByte(write_device_address))``     {``	   delay_us();``	   if(I2C_SendByte(read_data_address))``	     {``		    I2C_Start();``            I2C_SendByte(read_device_address);``	        readbyte=I2C_ReceiveByte();````	  	    read_ok=1;``		 }``	   else``	     {``	       I2C_Stop();``		   read_ok=0;``		 }``	  }``    else``	  {``	    I2C_Stop();``		read_ok=0;``	  }``   I2C_Stop();``   return(read_ok);``   ``} ````void main(void)``{``   initial();````   I2C_Init();``   if(WriteByte_to_24c04(0xcc,0x47))``     { ``	   led2=0; ``       write_command_to_LCD(0xc1,1);``       write_data_to_LCD(0x48); ``       if(ReadByte_from_24c04(0xcc))``	     {``	        led3=0;  ``			write_command_to_LCD(0x81,1);``            write_data_to_LCD(readbyte);``		 }``	 }``````   while(1);``}~~2~~3~~4~~5~~6
